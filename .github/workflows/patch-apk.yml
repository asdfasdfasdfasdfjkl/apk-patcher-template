name: Patch Android APK

on:
  workflow_dispatch:
    inputs:
      build_id:
        description: 'Build ID'
        required: true
      app_name:
        description: 'App Name'
        required: true
      version_code:
        description: 'Version Code'
        required: true
      version_name:
        description: 'Version Name'
        required: true
      contact_email:
        description: 'Contact Email'
        required: false
      build_type:
        description: 'Build Type (release/debug)'
        required: true
        default: 'release'

jobs:
  patch-apk:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install APK tools
        run: |
          sudo apt-get update
          sudo apt-get install -y apktool zipalign apksigner
          npm install sharp
      
      - name: Read build configuration
        id: config
        run: |
          echo "build_id=$(node -p "require('./build-config.json').build_id")" >> $GITHUB_OUTPUT
          echo "app_name=$(node -p "require('./build-config.json').app_name")" >> $GITHUB_OUTPUT
          echo "version_code=$(node -p "require('./build-config.json').version_code")" >> $GITHUB_OUTPUT
          echo "version_name=$(node -p "require('./build-config.json').version_name")" >> $GITHUB_OUTPUT
      
      - name: Patch APK
        run: |
          # Create Node.js script for patching
          cat > patch.js << 'EOF'
          const { execSync } = require('child_process');
          const fs = require('fs');
          const sharp = require('sharp');
          const path = require('path');

          const APK = 'base.apk';
          const APP_NAME = '${{ steps.config.outputs.app_name }}';
          const BUILD_ID = '${{ steps.config.outputs.build_id }}';
          const VERSION_CODE = '${{ steps.config.outputs.version_code }}';
          const VERSION_NAME = '${{ steps.config.outputs.version_name }}';
          const ICON_PATH = 'app_icon.webp';
          const KEYSTORE = 'keystore.jks';
          const ALIAS = 'mykey';
          const PASS = 'Hossain@11223';

          // Standard Android icon sizes
          const ICON_SIZES = {
            'mipmap-xxxhdpi': 192,
            'mipmap-xxhdpi': 144,
            'mipmap-xhdpi': 96,
            'mipmap-hdpi': 72,
            'mipmap-mdpi': 48,
            'mipmap': 48,
            'mipmap-ldpi': 36,
          };

          function run(cmd) {
            console.log('> ' + cmd);
            execSync(cmd, { stdio: 'inherit' });
          }

          // 1. Decode APK
          console.log('\nüì¶ Decoding APK...');
          run(`apktool d ${APK} -f -o decoded`);

          // 2. Patch BUILD_ID in smali files
          console.log('\nüîß Patching BUILD_ID...');
          function findFiles(dir, keyword) {
            let results = [];
            if (!fs.existsSync(dir)) return results;
            
            fs.readdirSync(dir).forEach(file => {
              const full = path.join(dir, file);
              if (fs.statSync(full).isDirectory()) {
                results = results.concat(findFiles(full, keyword));
              } else if (file.includes(keyword) && file.endsWith('.smali')) {
                results.push(full);
              }
            });
            return results;
          }

          const smaliFiles = findFiles('decoded', 'BuildConfig');
          if (smaliFiles.length === 0) {
            console.log('‚ö†Ô∏è No BuildConfig.smali found, skipping BUILD_ID patch');
          } else {
            smaliFiles.forEach(file => {
              let data = fs.readFileSync(file, 'utf8');
              // Try different patterns for BUILD_ID
              const patterns = [
                /const-string v\d, "\d+"\s+\w+ .+?BuildConfig;->BUILD_ID:Ljava\/lang\/String;/,
                /const-string \w+, ".*?"\s+\w+ \w+, Lcom\/\w+\/\w+\/BuildConfig;->BUILD_ID:Ljava\/lang\/String;/,
                /sput-object .+?BuildConfig;->BUILD_ID:Ljava\/lang\/String;/
              ];
              
              patterns.forEach(pattern => {
                if (pattern.test(data)) {
                  data = data.replace(pattern, `const-string v0, "${BUILD_ID}"\n    sput-object v0, Lcom/qavola/universalwebview/BuildConfig;->BUILD_ID:Ljava/lang/String;`);
                }
              });
              
              fs.writeFileSync(file, data);
              console.log(`  ‚úì Patched: ${file}`);
            });
          }

          // 3. Change App Name
          console.log('\nüìù Updating app name...');
          const stringsPath = 'decoded/res/values/strings.xml';
          if (fs.existsSync(stringsPath)) {
            let strings = fs.readFileSync(stringsPath, 'utf8');
            strings = strings.replace(
              /<string name="app_name">.*?<\/string>/,
              `<string name="app_name">${APP_NAME}</string>`
            );
            fs.writeFileSync(stringsPath, strings);
            console.log(`  ‚úì App name set to: ${APP_NAME}`);
          }

          // 4. Update Version in AndroidManifest.xml
          console.log('\nüìä Updating version...');
          const manifestPath = 'decoded/AndroidManifest.xml';
          if (fs.existsSync(manifestPath)) {
            let manifest = fs.readFileSync(manifestPath, 'utf8');
            manifest = manifest.replace(
              /android:versionCode="\d+"/,
              `android:versionCode="${VERSION_CODE}"`
            );
            manifest = manifest.replace(
              /android:versionName="[^"]+"/,
              `android:versionName="${VERSION_NAME}"`
            );
            fs.writeFileSync(manifestPath, manifest);
            console.log(`  ‚úì Version: ${VERSION_NAME} (${VERSION_CODE})`);
          }

          // 5. Replace Icons
          console.log('\nüé® Replacing icons...');
          async function replaceIcons() {
            if (!fs.existsSync(ICON_PATH)) {
              console.log('  ‚ö†Ô∏è No icon file found, skipping icon replacement');
              return;
            }

            const resPath = 'decoded/res';
            if (!fs.existsSync(resPath)) {
              console.log('  ‚ö†Ô∏è No res folder found');
              return;
            }

            const folders = fs.readdirSync(resPath).filter(f => 
              f.startsWith('mipmap') || f.startsWith('drawable')
            );

            for (const folder of folders) {
              const folderPath = path.join(resPath, folder);
              if (!fs.existsSync(folderPath)) continue;
              
              let targetSize = ICON_SIZES[folder] || 48;
              const files = fs.readdirSync(folderPath);
              
              for (const file of files) {
                if ((file.includes('ic_launcher') || file.includes('icon')) && 
                    (file.endsWith('.png') || file.endsWith('.webp') || file.endsWith('.jpg'))) {
                  
                  const fullPath = path.join(folderPath, file);
                  console.log(`  üîÑ Replacing: ${folder}/${file} (${targetSize}x${targetSize}px)`);
                  
                  await sharp(ICON_PATH)
                    .resize(targetSize, targetSize, {
                      fit: 'contain',
                      background: { r: 0, g: 0, b: 0, alpha: 0 }
                    })
                    .png({ compressionLevel: 9, adaptiveFiltering: true })
                    .toFile(fullPath + '.tmp')
                    .then(() => {
                      fs.renameSync(fullPath + '.tmp', fullPath);
                    })
                    .catch(err => {
                      console.error(`  ‚ùå Error processing ${fullPath}:`, err.message);
                    });
                }
              }
            }
          }

          await replaceIcons();

          // 6. Fix AndroidManifest.xml for icons
          if (fs.existsSync(manifestPath)) {
            let manifest = fs.readFileSync(manifestPath, 'utf8');
            
            if (!manifest.includes('android:icon=')) {
              manifest = manifest.replace(
                '<application',
                '<application android:icon="@mipmap/ic_launcher"'
              );
            }
            
            if (!manifest.includes('android:roundIcon=')) {
              manifest = manifest.replace(
                '<application',
                '<application android:roundIcon="@mipmap/ic_launcher_round"'
              );
            }
            
            fs.writeFileSync(manifestPath, manifest);
          }

          // 7. Rebuild APK
          console.log('\nüî® Rebuilding APK...');
          run('apktool b decoded -o unsigned.apk');

          // 8. Zipalign
          console.log('\n‚ö° Aligning APK...');
          run('zipalign -v -p 4 unsigned.apk aligned.apk');

          // 9. Sign
          console.log('\nüîê Signing APK...');
          run(`apksigner sign --ks ${KEYSTORE} --ks-key-alias ${ALIAS} --ks-pass pass:${PASS} --key-pass pass:${PASS} aligned.apk`);

          // 10. Rename output
          const safeAppName = APP_NAME.replace(/[^a-z0-9]/gi, '-').toLowerCase();
          const outputName = `${safeAppName}-${VERSION_NAME}-${BUILD_ID}.apk`;
          fs.renameSync('aligned.apk', outputName);
          
          console.log('\n‚úÖ APK Patched & Signed Successfully!');
          console.log(`üì± Output: ${outputName}`);

          // 11. Create info file
          const stats = fs.statSync(outputName);
          const info = {
            build_id: BUILD_ID,
            app_name: APP_NAME,
            version_code: VERSION_CODE,
            version_name: VERSION_NAME,
            file_name: outputName,
            file_size: stats.size,
            created_at: new Date().toISOString()
          };
          
          fs.writeFileSync('build-info.json', JSON.stringify(info, null, 2));
          EOF
          
          node patch.js
      
      - name: Upload APK as artifact
        uses: actions/upload-artifact@v3
        with:
          name: patched-apk
          path: "*.apk"
          retention-days: 7
      
      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: build-${{ steps.config.outputs.build_id }}
          name: ${{ steps.config.outputs.app_name }} v${{ steps.config.outputs.version_name }}
          body: |
            Build ID: ${{ steps.config.outputs.build_id }}
            App Name: ${{ steps.config.outputs.app_name }}
            Version: ${{ steps.config.outputs.version_name }} (${{ steps.config.outputs.version_code }})
          files: |
            *.apk
            build-info.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create status file in repo
        run: |
          echo '{
            "status": "completed",
            "conclusion": "success",
            "build_id": "${{ steps.config.outputs.build_id }}",
            "app_name": "${{ steps.config.outputs.app_name }}",
            "version_name": "${{ steps.config.outputs.version_name }}",
            "version_code": "${{ steps.config.outputs.version_code }}",
            "download_url": "https://github.com/${{ github.repository }}/releases/download/build-${{ steps.config.outputs.build_id }}/${{ steps.config.outputs.app_name }}-${{ steps.config.outputs.version_name }}-${{ steps.config.outputs.build_id }}.apk",
            "completed_at": "${{ github.event.repository.updated_at }}"
          }' > build-status.json
          
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add build-status.json
          git commit -m "Add build status for ${{ steps.config.outputs.build_id }}" || true
          git push