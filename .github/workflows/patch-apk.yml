name: Build Patched APK

on:
  workflow_dispatch:
    inputs:
      buildId:
        description: 'Build ID'
        required: true
        type: string
      appName:
        description: 'App Name'
        required: true
        type: string
      websiteUrl:
        description: 'Website URL'
        required: true
        type: string
      iconBase64:
        description: 'App Icon (Base64)'
        required: false
        type: string
      contactEmail:
        description: 'Contact Email'
        required: true
        type: string

env:
  BUILD_ID: ${{ github.event.inputs.buildId }}
  APP_NAME: ${{ github.event.inputs.appName }}
  WEBSITE_URL: ${{ github.event.inputs.websiteUrl }}
  ICON_BASE64: ${{ github.event.inputs.iconBase64 }}
  CONTACT_EMAIL: ${{ github.event.inputs.contactEmail }}
  
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
  API_BASE_URL: ${{ secrets.API_BASE_URL }}
  BUILD_SECRET: ${{ secrets.BUILD_SECRET }}

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Install apktool
      run: |
        wget -q https://github.com/iBotPeaches/Apktool/releases/download/v2.9.3/apktool_2.9.3.jar
        wget -q https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool
        mv apktool_2.9.3.jar apktool.jar
        chmod +x apktool apktool.jar
        sudo mv apktool* /usr/local/bin/
        apktool --version
    
    - name: Install sharp
      run: |
        npm init -y
        npm install sharp
        echo "âœ… Sharp installed"
    
    - name: Install required tools
      run: |
        sudo apt-get update
        sudo apt-get install -y zipalign apksigner
    
    - name: Create icon from base64
      if: env.ICON_BASE64 != ''
      run: |
        echo "$ICON_BASE64" | base64 -d > icon.webp
        echo "âœ… Icon created: $(file icon.webp)"
        ls -la icon.webp
    
    - name: Decode APK
      run: |
        apktool d base.apk -f -o decoded

    - name: Patch BUILD_ID
      run: |
        echo "Patching BUILD_ID with: $BUILD_ID"
        # Find the file and replace the BUILD_ID value
        find decoded -name "BuildConfig.smali" -exec sed -i "s/const-string v0, \"[^\"]*\"/const-string v0, \"$BUILD_ID\"/g" {} \; 2>/dev/null || echo "No BuildConfig.smali found"
        
        echo "--- VERIFICATION ---"
        find decoded -name "BuildConfig.smali" -exec grep -A2 -B1 "sput-object.*BUILD_ID" {} \; || echo "BuildConfig.smali not found"

    
    - name: Change App Name
      run: |
        if [ -f "decoded/res/values/strings.xml" ]; then
          sed -i "s|<string name=\"app_name\">.*</string>|<string name=\"app_name\">$APP_NAME</string>|g" decoded/res/values/strings.xml
          echo "âœ… App name changed to: $APP_NAME"
        else
          echo "strings.xml not found"
        fi
    
    - name: Replace Icons (exactly like patch.js)
      if: env.ICON_BASE64 != ''
      run: |
        node -e "
        const fs = require('fs');
        const path = require('path');
        const sharp = require('sharp');

        const ICON_PATH = 'icon.webp';
        const BASE_PATH = 'decoded/res';

        // Standard Android icon sizes
        const ICON_SIZES = {
          'mipmap-xxxhdpi': 192,
          'mipmap-xxhdpi': 144,
          'mipmap-xhdpi': 96,
          'mipmap-hdpi': 72,
          'mipmap-mdpi': 48,
          'mipmap': 48,
          'mipmap-ldpi': 36,
        };

        async function replaceIcons() {
          try {
            // Check if icon exists
            if (!fs.existsSync(ICON_PATH)) {
              console.log('No icon file found, skipping...');
              return;
            }

            // Check if base path exists
            if (!fs.existsSync(BASE_PATH)) {
              console.log('No res folder found, skipping...');
              return;
            }

            // Get source icon metadata
            const sourceIcon = sharp(ICON_PATH);
            const metadata = await sourceIcon.metadata();
            console.log(\`ðŸ“± Source icon: \${metadata.width}x\${metadata.height} pixels\`);

            // Find all mipmap and drawable folders
            const folders = fs.readdirSync(BASE_PATH).filter(f => 
              f.startsWith('mipmap') || f.startsWith('drawable')
            );

            console.log('Found folders:', folders.join(', '));

            // Collect all promises
            const promises = [];

            folders.forEach(folder => {
              const folderPath = path.join(BASE_PATH, folder);
              
              if (!fs.existsSync(folderPath)) return;
              
              // Get target size for this folder
              let targetSize = ICON_SIZES[folder] || 48;

              const files = fs.readdirSync(folderPath);
              
              files.forEach(file => {
                // Look for icon files
                if ((file.includes('ic_launcher') || file.includes('icon')) && 
                    (file.endsWith('.png') || file.endsWith('.webp'))) {
                  
                  const fullPath = path.join(folderPath, file);
                  const outputFormat = file.endsWith('.png') ? 'png' : 'webp';
                  
                  console.log(\`ðŸ”„ Replacing: \${folder}/\${file} (\${targetSize}x\${targetSize}px)\`);
                  
                  // Create promise for this icon
                  const promise = sharp(ICON_PATH)
                    .resize(targetSize, targetSize, {
                      fit: 'contain',
                      background: { r: 0, g: 0, b: 0, alpha: 0 }
                    })
                    [outputFormat]({
                      quality: 90,
                      lossless: outputFormat === 'png'
                    })
                    .toFile(fullPath + '.tmp')
                    .then(() => {
                      fs.renameSync(fullPath + '.tmp', fullPath);
                      console.log(\`  âœ… Replaced: \${folder}/\${file}\`);
                    })
                    .catch(err => {
                      console.error(\`  âŒ Error processing \${fullPath}:\`, err.message);
                    });
                  
                  promises.push(promise);
                }
              });
            });

            // Wait for all icons to be processed
            await Promise.all(promises);
            console.log('âœ… All icons replaced successfully');

          } catch (error) {
            console.error('âŒ Error in replaceIcons:', error);
            throw error;
          }
        }

        async function replaceAdaptiveIcons(base, iconPath) {
          // Adaptive icons are stored in mipmap-anydpi-v26 folders
          const folders = fs.readdirSync(base).filter(f => 
            f.includes('anydpi-v26') || f.includes('v26')
          );

          const promises = [];

          folders.forEach(folder => {
            const folderPath = path.join(base, folder);
            if (!fs.existsSync(folderPath)) return;

            const files = fs.readdirSync(folderPath);
            
            files.forEach(file => {
              if (file.includes('ic_launcher') && file.endsWith('.xml')) {
                // Adaptive icons use XML, we need to replace the referenced PNG/WebP files
                const xmlPath = path.join(folderPath, file);
                const xml = fs.readFileSync(xmlPath, 'utf8');
                
                // Extract referenced image files
                const matches = xml.match(/android:drawable=\"@[^\"]+\"/g) || [];
                matches.forEach(match => {
                  const drawablePath = match.replace('android:drawable=\"', '').replace('\"', '');
                  // Find and replace the actual image files
                  // This is complex - simplest is to just replace the foreground/background images
                  if (drawablePath.includes('foreground') || drawablePath.includes('background')) {
                    // Look for corresponding PNG/WebP files in other mipmap folders
                    // For simplicity, we'll just ensure we have an icon in all folders
                  }
                });
              }
            });
          });

          await Promise.all(promises);
        }

        async function fixAndroidManifest() {
          const manifestPath = 'decoded/AndroidManifest.xml';
          if (fs.existsSync(manifestPath)) {
            try {
              let manifest = fs.readFileSync(manifestPath, 'utf8');
              
              if (!manifest.includes('android:icon=')) {
                manifest = manifest.replace(
                  '<application', 
                  '<application android:icon=\"@mipmap/ic_launcher\"'
                );
              }
              
              if (!manifest.includes('android:roundIcon=')) {
                manifest = manifest.replace(
                  '<application', 
                  '<application android:roundIcon=\"@mipmap/ic_launcher_round\"'
                );
              }
              
              fs.writeFileSync(manifestPath, manifest);
              console.log('âœ… AndroidManifest.xml updated with icon references');
            } catch (err) {
              console.error('âŒ Error updating AndroidManifest.xml:', err.message);
            }
          }
        }

        async function main() {
          console.log('ðŸŽ¨ Starting icon replacement process...');
          await replaceIcons();
          await replaceAdaptiveIcons(BASE_PATH, ICON_PATH);
          await fixAndroidManifest();
          console.log('âœ… Icon replacement completed');
        }

        main().catch(err => {
          console.error('âŒ Fatal error:', err);
          process.exit(1);
        });
        "
    
    - name: Verify icons were replaced
      if: env.ICON_BASE64 != ''
      run: |
        echo "ðŸ“ Checking replaced icons:"
        find decoded/res -name "*.png" -o -name "*.webp" | grep -i "ic_launcher" | head -10 || echo "No icon files found"
    
    - name: Rebuild APK
      run: |
        apktool b decoded -o unsigned.apk
    
    - name: Zipalign
      run: |
        zipalign -v 4 unsigned.apk aligned.apk
    
    - name: Sign APK
      run: |
        if [ ! -f "keystore.jks" ]; then
          echo "âš ï¸ Keystore not found, generating new one..."
          keytool -genkey -v -keystore keystore.jks -keyalg RSA -keysize 2048 \
            -validity 10000 -alias mykey -storepass Hossain@11223 -keypass Hossain@11223 \
            -dname "CN=Qavola, OU=Development, O=Qavola, L=City, ST=State, C=US"
        fi
        
        apksigner sign --ks keystore.jks --ks-key-alias mykey --ks-pass pass:Hossain@11223 \
          --key-pass pass:Hossain@11223 aligned.apk
        
        mv aligned.apk ${{ github.event.inputs.buildId }}.apk
        echo "âœ… APK signed successfully"
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    
    - name: Upload to S3
      id: upload
      run: |
        FILENAME="builds/$BUILD_ID/$BUILD_ID.apk"
        
        aws s3 cp $BUILD_ID.apk s3://$AWS_S3_BUCKET/$FILENAME
        
        PRESIGNED_URL=$(aws s3 presign s3://$AWS_S3_BUCKET/$FILENAME --expires-in 604800)
        
        FILE_SIZE=$(stat -c%s "$BUILD_ID.apk")
        
        echo "download_url=$PRESIGNED_URL" >> $GITHUB_OUTPUT
        echo "file_size=$FILE_SIZE" >> $GITHUB_OUTPUT
        echo "âœ… Uploaded to S3: $FILENAME"

    - name: Call webhook to update build status
      if: always()
      run: |
        # Determine status based on previous steps
        if [ "${{ job.status }}" == "success" ]; then
          STATUS="completed"
          CONCLUSION="success"
        else
          STATUS="completed"
          CONCLUSION="failure"
        fi
        
        # Call the webhook with build information
        curl -X GET "${{ secrets.API_BASE_URL }}/api/build-status?buildId=${{ github.event.inputs.buildId }}&github-action=true" \
          -H "Authorization: Bearer ${{ secrets.BUILD_SECRET }}" \
          -H "Content-Type: application/json" \
          --fail \
          --silent \
          --show-error \
          --output /dev/null \
          -w "Webhook called with status: %{http_code}\n"
        
        echo "âœ… Build status webhook sent: $CONCLUSION"
    
    - name: Cleanup
      if: always()
      run: |
        rm -rf decoded unsigned.apk aligned.apk *.apk *.png *.webp || true
        echo "âœ… Cleanup completed"
